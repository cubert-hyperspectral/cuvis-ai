
# Project Tooling Overview

- **uv** — canonical dependency and workflow manager (environment sync, task runners, lockfile management, builds, test invocation).
- **PyTorch (`torch`)** — core tensor and GPU computation library for all data processing nodes, with optional ecosystem packages such as TorchVision and torch-cluster for specialized ops.
- **PyTorch Lightning** — standardized training orchestration layer used for model workflows and callbacks.
- **pytest** / **pytest-cov** — required test runner and coverage tooling for unit, integration, and workflow smoke tests.
- **Ruff** — linting and formatting suite configured via `pyproject.toml` and executed through `uv run`.
- **Matplotlib** — visualization backend for generating figures within Hamilton workflows.
- **Loguru** — structured logging utility adopted for runtime messaging. Don’t use `print` for logging. Do `from loguru import logger`, and then use `logger` in the script to show messages like the print command.
- **MkDocs + Material + mkdocstrings** — recommended autodocumentation stack for generating the node catalog and workflow guides.
- **Licensing** — dependencies should be open-source and have a permissive license (e.g., MIT, BSD, Apache-2.0). Always verify license terms before introducing new packages.
- **Hydra** — configuration management and CLI framework built on OmegaConf; provides type-safe config overrides, validation, and composition for workflow CLIs. Prefer Hydra over argparse or Fire for new CLI interfaces.
- **dotenv** for variable loading. use with reload.
- **MLflow** for Registry + packaging + serving.
- **hydra** for using the congfis with override cli mechanism

---

## Development Guardrails

### Testing
- **Always use pytest** for running tests: `uv run pytest`
- Write unit tests in `tests/` directory following existing structure
- Use `pytest-cov` for coverage reports: `uv run pytest --cov`
- Integration tests should go in appropriate subdirectories (e.g., `tests/training/`, `tests/stress/`)
- Reuse Fixtures as much as possible and avoid one-time fixture creation preferably

### Running Commands
- **Always use `uv run`** to execute Python scripts and commands (ensures correct environment)
  - Example: `uv run python examples_torch/phase1_statistical_training.py`
  - Example: `uv run pytest tests/`
- Use `uv sync` to ensure dependencies are up to date before running tests or examples
- Never use bare `python` or `pip` commands; always go through `uv`

### Code Quality
- Run **Ruff** for linting and formatting: `uv run ruff check .` and `uv run ruff format .`
- Format code before committing
- Address linting errors before creating pull requests
- Configuration is in `pyproject.toml`

### Logging
- **Never use `print()` for logging** in production code
- Use Loguru: `from loguru import logger` then `logger.info()`, `logger.debug()`, etc.
- Only use `print()` in example scripts for demonstration purposes

### Configuration
- Use **Hydra** for CLI configuration in new scripts
- Store configs in /configs/` directory
- Use OmegaConf for type-safe config access
- Prefer Hydra over argparse or Fire for new CLI interfaces

### Documentation
- Avoid long or excessive docstrings. Keep docstrings short and concise; omit them when unnecessary.
- Document all public APIs using docstrings
- Use MkDocs-compatible format (Google or NumPy style)
- Update relevant docs in `docs/` when adding features
- Keep `docs_dev/` for internal design documents and blueprints

### Dependencies
- Only add dependencies with permissive licenses (MIT, BSD, Apache-2.0)
- Verify license terms before introducing new packages
- Add new dependencies via `uv add <package>`
- Document any new major dependencies in this file

